# Module 17: Demultiplexing and NGS Data Processing with Python

"""
Learning Objectives:
- Understand demultiplexing strategies for NGS data.
- Perform quality control (QC) of NGS datasets.
- Implement read trimming and filtering techniques.
- Develop a Python-based demultiplexing algorithm.
- Create a Galaxy workflow for demultiplexing.
- Apply concepts to a hands-on project using real NGS data.

Key Concepts Covered:
1. Demultiplexing strategies for NGS data
2. Quality control (QC)
3. Read trimming and filtering
4. Algorithm implementation in Python
5. Workflow integration in Galaxy
"""


# 1. Demultiplexing Strategies for NGS Data
# Demultiplexing splits multiplexed datasets into individual samples based on barcodes.
# Example: A simple Python implementation to identify barcodes in reads.
# Next-generation sequencing (NGS) is a modern method for analyzing DNA or RNA that can quickly sequence large amounts of genetic material. NGS is different from traditional sequencing methods because it can sequence millions of DNA fragments at once. This allows researchers to expand the scale and discovery power of their genomic studies. However, the large amount of data generated by NGS requires specialized tools and techniques for processing and analysis. In this module, we will explore demultiplexing, quality control, and read trimming techniques for NGS data using Python.

def demultiplex_reads(reads: list[str], barcodes: list[str]):
    """
    Splits reads into samples based on barcodes.

    Args:
        reads (list): List of DNA reads.
        barcodes (dict): Dictionary mapping barcodes to sample names.

    Returns:
        dict: Dictionary of demultiplexed reads by sample.
    """
    demultiplexed = {sample: [] for sample in barcodes.values()}
    for read in reads:
        for barcode, sample in barcodes.items():
            if read.startswith(barcode):
                demultiplexed[sample].append(read)
                break
    return demultiplexed


# Example input
reads = ["ATGC_sample1", "CGTA_sample2", "ATGC_sample1"]
barcodes = {"ATGC": "Sample1", "CGTA": "Sample2"}
print(f"Demultiplexed Reads: {demultiplex_reads(reads, barcodes)}")


# 2. Quality Control (QC)
# Perform QC by checking read quality scores.
def quality_control(read_qualities: list[tuple[str, int]], threshold=30):
    """
    Filters out low-quality reads.

    Args:
        read_qualities (list): List of tuples (read, quality_score).
        threshold (int): Minimum acceptable quality score.

    Returns:
        list: Filtered reads with quality above the threshold.
    """
    return [read for read, quality in read_qualities if quality >= threshold]


# Example input
read_qualities = [("ATGC", 35), ("CGTA", 25)]
print(f"Filtered Reads: {quality_control(read_qualities)}")


# 3. Read Trimming and Filtering
# Trimming low-quality ends from reads.
def trim_reads(reads: list[str], trim_length: int):
    """
    Trims reads to the specified length.

    Args:
        reads (list): List of DNA reads.
        trim_length (int): Length to trim reads to.

    Returns:
        list: Trimmed reads.
    """
    return [read[:trim_length] for read in reads]


# Example input
trimmed_reads = trim_reads(["ATGCGTAC", "CGTACGTA"], 5)
print(f"Trimmed Reads: {trimmed_reads}")


# 4. Implementing a Demultiplexing Algorithm
# Combining the demultiplexing logic into a pipeline function.
def process_ngs_data(reads, barcodes, quality_scores, trim_length, quality_threshold):
    """
    Full pipeline for demultiplexing, quality control, and trimming.

    Args:
        reads (list): List of DNA reads.
        barcodes (dict): Dictionary mapping barcodes to sample names.
        quality_scores (list): List of tuples (read, quality_score).
        trim_length (int): Length to trim reads to.
        quality_threshold (int): Minimum acceptable quality score.

    Returns:
        dict: Fully processed reads by sample.
    """
    # Step 1: Filter reads by quality
    high_quality_reads = quality_control(quality_scores, quality_threshold)
    # Step 2: Trim reads
    trimmed_reads = trim_reads(high_quality_reads, trim_length)
    # Step 3: Demultiplex reads
    return demultiplex_reads(trimmed_reads, barcodes)


# 5. Workflow Integration in Galaxy
# Galaxy workflows can be defined using YAML or Python scripts.
# This section would cover how to create and upload the workflow.
# (Details not implemented here; tailored to Galaxy user interface.)

# 6. Hands-On Project
"""
Project: Process and demultiplex a raw NGS dataset.
- Input: Simulated dataset of multiplexed reads with barcodes.
- Goal: Generate quality-controlled, demultiplexed, and trimmed reads for downstream analysis.
"""


def hands_on_project():
    """
    Runs a demonstration project with simulated NGS data.
    """
    raw_reads = ["ATGCGTAC_sample1", "CGTACGTA_sample2"]
    barcodes = {"ATGC": "Sample1", "CGTA": "Sample2"}
    qualities = [("ATGCGTAC_sample1", 40), ("CGTACGTA_sample2", 20)]
    trimmed_length = 5
    quality_threshold = 30

    processed_reads = process_ngs_data(
        raw_reads, barcodes, qualities, trimmed_length, quality_threshold
    )
    print(f"Processed Reads: {processed_reads}")


# Uncomment to run the project demonstration
# hands_on_project()
